# RGMII PHY on KR260 (DP83867 + AXI Ethernet)

This chapter documents the RGMII-based Ethernet PHY used in the KR260 PL Ethernet interface and how it is configured and used together with the **AXI 1G/2.5G Ethernet Subsystem (PG138)** and our Vitis software.

The focus is on:

- What RGMII actually is (signals, timing, clocking).
- How the **TI DP83867** PHY on the KR260 is wired and configured.
- How MDIO is used from software to control the PHY (BMCR/BMSR, autonegotiation, etc.).
- How the PHY and MAC (AXI Ethernet IP) interact to produce a working 1 Gbps link.

---

## 1. KR260 Ethernet Hardware Overview

According to the **KR260 User Guide (UG1092)**, the robotics carrier card exposes four Ethernet ports: two from the PS and two from the PL. For Part-1 we are interested in the **PL Ethernet ports**, which are RGMII interfaces. :contentReference[oaicite:0]{index=0}

> - **CC J10A** – “1 Gb/s Ethernet 3 (PL) RGMII interface on HPB”  
> - **CC J10B** – “1 Gb/s Ethernet 2 (PL) RGMII interface on HPA”

Each of these RGMII ports is implemented with a **TI DP83867** Gigabit Ethernet PHY. The PHY connects:

- On one side to the **RJ45 + magnetics** (twisted pair, 1000BASE-T copper).
- On the other side to the FPGA PL via **RGMII** (TXD[3:0], RXD[3:0], TXC, RXC, TX_CTL, RX_CTL). :contentReference[oaicite:1]{index=1}  

The PHY also has:

- A **25 MHz reference crystal/oscillator**.
- **MDC/MDIO** pins for management.
- A **reset pin** coming from the PL or SOM.
- Strap pins that select default mode at power-up (RGMII vs SGMII, clock delay, address, etc.). :contentReference[oaicite:2]{index=2}  

> **NOTE (screenshot):** Add a cropped piece of the KR260 schematic showing: RJ45 → magnetics → DP83867 → RGMII pins into the PL.

In our block design, the PL RGMII pins are routed directly into the **AXI 1G/2.5G Ethernet Subsystem** configured in **RGMII mode**, which acts as the MAC. :contentReference[oaicite:3]{index=3}  

---

## 2. What is RGMII?

### 2.1 Signal Set

RGMII = **Reduced Gigabit Media Independent Interface**. Compared to classic GMII (8-bit data + separate control at 125 MHz), RGMII:

- Uses **4 data bits** instead of 8.
- Uses a **double data rate (DDR)** scheme:  
  - **Rising edge** → lower nibble  
  - **Falling edge** → upper nibble
- Separates TX and RX directions with their own clocks.

Typical RGMII signal groups:

- **Transmit (MAC → PHY)**  
  - `TXD[3:0]`  
  - `TX_CTL` (encodes TX_EN and TX_ER)  
  - `TXC` (125 MHz clock generated by MAC)  

- **Receive (PHY → MAC)**  
  - `RXD[3:0]`  
  - `RX_CTL` (encodes RX_DV and RX_ER)  
  - `RXC` (125 MHz clock generated by PHY)

> **NOTE (screenshot):** Add the RGMII timing/bit diagram from the DP83867 datasheet (chapter “MAC Interface (RGMII/SGMII)”). :contentReference[oaicite:4]{index=4}  

### 2.2 Speeds and Clocks

The PHY supports 10 / 100 / 1000 Mb/s operation over copper. From the MAC’s perspective:

- For **1 Gbps**, RGMII uses **125 MHz TXC/RXC** with DDR (8 bits per 125 MHz clock = 1 Gbit/s).
- For **10/100 Mbps**, the PHY still works with a 125 MHz reference, but internally divides the clock and uses appropriate DDR patterns. The key point: **the AXI Ethernet IP still expects a 125 MHz gtx_clk / ref_clk** for RGMII operation; the PHY handles the slower line rate internally. :contentReference[oaicite:5]{index=5}  

This is why our Clocking Wizard always generates **125 MHz gtx_clk / ref_clk** for the AXI Ethernet core, regardless of negotiated line speed.

---

## 3. AXI Ethernet ↔ DP83867 Connection on KR260

### 3.1 MAC Side (AXI 1G/2.5G Ethernet Subsystem)

The AXI Ethernet core exposes an RGMII port with pins:  

- `rgmii_txd[3:0]`, `rgmii_tx_ctl`, `rgmii_txc`  
- `rgmii_rxd[3:0]`, `rgmii_rx_ctl`, `rgmii_rxc`  
- `mdio_mdc`, `mdio_mdio` (management)  
- `phy_rst_n` (PHY reset) :contentReference[oaicite:6]{index=6}  

These are connected 1-to-1 to the DP83867 pins on the carrier card.

> **NOTE (screenshot):** Add a screenshot of the AXI Ethernet block in Vivado, with RGMII ports visible.

### 3.2 PHY Side (DP83867 Overview)

From the DP83867 datasheet: :contentReference[oaicite:7]{index=7}  

- It is an IEEE 802.3 compliant **10/100/1000 Mbps copper PHY**.
- Supports **RGMII** and optionally **SGMII** (depending on variant).
- Uses internal PLLs to derive the necessary clocks from a 25 MHz reference.
- Has configuration via:
  - **Strap pins** at reset (mode, RGMII delay, PHY address).
  - **MDIO registers** for runtime control.

> **NOTE (screenshot):** Add the DP83867 block diagram figure showing the RGMII/SGMII/MII section.

On the KR260, the PHY is strapped for **RGMII mode** (RGMII enable bit set / SGMII disabled by default). Board straps also define the PHY address (`PHY_ADDR_CONFIG` in our Vitis code, e.g. `2`) and whether internal TX/RX clock delays are enabled. :contentReference[oaicite:8]{index=8}  

---

## 4. PHY Management via MDIO

### 4.1 MDIO Interface

The AXI Ethernet Subsystem includes a built-in **Media Independent Interface Management (MIIM)** block. When we call:

```c
XAxiEthernet_PhyRead(&EthInst, PhyAddr, RegNum, &Value);
XAxiEthernet_PhyWrite(&EthInst, PhyAddr, RegNum, Value);
```

the core:

Asserts MDC and drives MDIO according to the IEEE 802.3 MDIO frame format.

Sends an MDIO read or write transaction to the external PHY.

Returns the register value to software.

We do not bit-bang MDIO from software; all of this is handled by the MAC IP.

NOTE (screenshot): Add a small diagram from PG138 showing the MIIM block and MDIO pins.

4.2 Basic Registers: BMCR and BMSR

The two most important MDIO registers we use are:

Basic Mode Control Register (BMCR, address 0)

Basic Mode Status Register (BMSR, address 1)

We access them with:
#define PHY_REG_BMCR   0   // Basic Mode Control Register
#define PHY_REG_BMSR   1   // Basic Mode Status Register

#define BMCR_AUTONEG_EN  0x1000  // Autonegotiation Enable
#define BMCR_RESTART_AN  0x0200  // Restart Autonegotiation

#define BMSR_LINK_STATUS 0x0004  // Link Status bit (1 = link up)

BMCR (Reg 0)

Relevant bits for us:

Bit 15: Reset

Bit 13: Speed select MSB (1000 vs 10/100, depending on device)

Bit 12: Autonegotiation enable (BMCR_AUTONEG_EN)

Bit 8 : Duplex mode

Bit 9 : Restart autonegotiation (BMCR_RESTART_AN)

In our init code:

u16 Bmcr;
XAxiEthernet_PhyRead(&EthInst, PhyAddr, PHY_REG_BMCR, &Bmcr);
Bmcr |= BMCR_AUTONEG_EN | BMCR_RESTART_AN;
XAxiEthernet_PhyWrite(&EthInst, PhyAddr, PHY_REG_BMCR, Bmcr);


This means:

Ensure autoneg is enabled.

Explicitly trigger a Restart Autonegotiation so that the PHY re-negotiates speed/duplex with the link partner after reset.

BMSR (Reg 1)

BMSR_LINK_STATUS = 1 indicates that the PHY reports link up.

In our code we poll this bit:

u16 Bmsr;
for (i = 0; i < 100; i++) {
    XAxiEthernet_PhyRead(&EthInst, PhyAddr, PHY_REG_BMSR, &Bmsr);
    XAxiEthernet_PhyRead(&EthInst, PhyAddr, PHY_REG_BMSR, &Bmsr); // read twice as per spec
    if (Bmsr & BMSR_LINK_STATUS) {
        xil_printf("  LINK UP, BMSR = 0x%04x\r\n", Bmsr);
        break;
    }
    usleep(100000);
}


Some PHYs latch the link bit and require two reads to get the current value, hence the double read.

If after the timeout the link status is still 0, we print a warning.

5. RGMII Configuration in DP83867

The DP83867 has a set of device-specific registers that control RGMII behavior (in addition to the standard IEEE registers). For example, the datasheet defines an RGMII Control Register at address 0x0032 with bits that enable RGMII mode and control internal clock delays.

Important aspects (summarised):

RGMII Enable / Disable
Determines whether the MAC interface uses RGMII or SGMII.

TX/RX Clock Delay Enable
RGMII requires a certain skew between clock and data (about 1.8–2.0 ns typical).
This can be implemented on the board (length-matching / routing) or internally in the PHY.

On KR260:

The carrier card straps set the PHY into RGMII mode with appropriate delays by default.

We therefore do not manually touch registers like RGMIICTL in our basic bring-up code; the board defaults are already correct.

NOTE (screenshot): Add a table snippet from DP83867 showing RGMIICTL bits (RGMII_EN, TX/RX delay bits).

If needed, additional tuning (e.g. enabling internal delays or changing RX clock phase) could be performed by:

u16 val;
XAxiEthernet_PhyRead(&EthInst, PhyAddr, 0x0032, &val);
// modify RGMII delay bits here
XAxiEthernet_PhyWrite(&EthInst, PhyAddr, 0x0032, val);


but this was not required for our KR260 setup.

6. MAC Speed vs PHY Autonegotiation

A common point of confusion:

The PHY negotiates the actual line speed (10/100/1000) and duplex with the link partner via autoneg.

The MAC (AXI Ethernet) does not automatically “read” that speed; we must configure it explicitly using:

Status = XAxiEthernet_SetOperatingSpeed(&EthInst, XAE_SPEED_1000_MBPS);


This sets internal logic in the MAC core (e.g. assumptions about clock frequencies, IP-level behaviour). In our design we always force the MAC to 1000 Mbps mode, because:

The KR260 RGMII PHY and our test environment are all Gigabit-capable.

The MAC still uses 125 MHz clocks even if the link ended up at 100/10 Mbps; the PHY handles line-rate differences.

If one would support 10/100 as well, a typical flow would be:

Use MDIO to read PHY speed/duplex result (often in vendor-specific registers).

Call XAxiEthernet_SetOperatingSpeed() with matching speed.

Optionally adjust MAC configuration (flow control, pause, etc.).

7. Reset and Power-Up Sequence

A robust bring-up sequence for RGMII PHY on KR260 looks like this:

System Power-Up

25 MHz reference clock is running.

PHY comes out of reset with strap pins sampled → RGMII mode, correct PHY address, etc.

PL Configuration / Bitstream Download

AXI Ethernet core becomes active.

phy_rst_n output of the MAC is still held low by the reset logic.

Release PHY Reset from PL

Our reset chain (e.g. proc_sys_reset) deasserts phy_rst_n.

PHY re-samples strap pins and starts autonegotiation (if enabled by straps).

Vitis Software Initialization

Call XAxiEthernet_LookupConfig and XAxiEthernet_CfgInitialize.

Set MAC options, MAC address, etc.

Call XAxiEthernet_SetOperatingSpeed(.., XAE_SPEED_1000_MBPS).

Enable / restart autoneg via BMCR.

Poll BMSR until LINK_STATUS = 1.

Enable TX/RX Datapaths

Call XAxiEthernet_Start(&EthInst) (enables TX/RX logic).

From this point, RGMII data and clocks are actively used.

NOTE (screenshot): Add a simple timing diagram you draw (or a PlantUML sequence) showing reset → MDIO config → link up.

8. Debugging Tips for RGMII/PHY

Some practical checks when something goes wrong:

Check Link LEDs on RJ45
If LEDs stay off:

PHY might not be powered or not out of reset.

Autoneg may be disabled or misconfigured.

Read BMSR over MDIO

If LINK_STATUS never goes 1, verify cabling, remote side, or BMCR autoneg bits.

Verify PHY Address

If MDIO reads always return 0xFFFF or 0x0000, you might be using the wrong PhyAddr in software.

Check board documentation for strap settings.

Check RGMII Mode Registers

Make sure RGMII is enabled (RGMII_EN in DP83867).

Confirm internal clock delays are enabled/disabled as the board expects.

Scope the RGMII Clocks (TXC/RXC)

At 1 Gbps you should see a clean 125 MHz clock with fast edges.

If clocks are missing, check MAC enable and PHY reset.

Loopback Tests

DP83867 supports internal loopback modes; these can be enabled via vendor registers to isolate MAC vs PHY vs cable issues.

9. Summary

In the KR260 Part-1 design:

The AXI 1G/2.5G Ethernet Subsystem is configured in RGMII mode and connects directly to a TI DP83867 PHY on the carrier card.

A 25 MHz reference clock and board strap pins configure the PHY into the correct default (RGMII + desired delays and address).

The MAC controls the PHY via MDIO and uses standard IEEE registers BMCR (0) and BMSR (1) to:

Enable and restart autonegotiation.

Poll link status.

The MAC still requires 125 MHz clocks for RGMII operation. Line speed negotiation is handled inside the PHY; we statically configure the MAC for 1 Gbps.

Correct RGMII operation is a prerequisite for the rest of the RDMA pipeline; once the PHY link is up and RGMII is stable, RX data is passed into the custom AXI-Stream buffering and RDMA decapsulation logic described in the following sections.

This chapter provides the hardware-level context needed to understand how Ethernet frames arrive from the outside world and enter the FPGA fabric in our RDMA design.